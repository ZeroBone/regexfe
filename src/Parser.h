/* This file was generated by Grammax v1.1.1 */

#ifndef GRAMMAX_PARSER_PARSER_H
#define GRAMMAX_PARSER_PARSER_H
#include <vector>
#include <cstring> // for std::memcpy

class Parser {
private:
#define T_WORD_CHARS 0
#define T_OR 1
#define T_LITERAL 2
#define T_RIGHT_PARENTHESIS 3
#define T_LEFT_BRACKET 4
#define T_NON_DIGIT_CHARS 5
#define T_NON_WHITESPACE_CHARS 6
#define T_DOT 7
#define T_UP_ARROW 8
#define T_LEFT_PARENTHESIS_QUESTION_MARK_COLON 9
#define T_MINUS 10
#define T_DIGIT_CHARS 11
#define T_RIGHT_BRACKET 12
#define T_LEFT_PARENTHESIS 13
#define T_NON_WORD_CHARS 14
#define T_WHITESPACE_CHARS 15
#define T_QUESTION_MARK 16
#define T_STAR 17
#define T_CHARACTER 18
#define T_PLUS 19
#define T_EOF 20
#define TERMINAL_COUNT 21
#define NON_TERMINAL_COUNT 10
    static constexpr int gotoTable[] = {
        13,17,0,9,3,18,0,0,11,2,
        0,0,0,0,0,0,0,23,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        24,17,0,9,3,18,0,0,11,2,
        0,0,0,0,0,0,0,0,0,0,
        0,0,28,30,0,0,29,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,31,0,9,3,18,0,0,11,2,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,33,0,9,3,18,0,0,11,2,
        34,17,0,9,3,18,0,0,11,2,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,28,30,0,0,36,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,28,30,0,0,39,0,0,0,
        0,0,28,30,0,0,40,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,28,30,0,0,42,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        43,17,0,9,3,18,0,0,11,2,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,28,30,0,0,47,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0};
    static constexpr int actionTable[] = {
        4,0,6,-4,7,14,10,15,0,19,0,8,0,5,16,12,0,0,0,0,-4,
        -12,-12,-12,-12,-12,-12,-12,-12,0,-12,0,-12,0,-12,-12,-12,21,20,0,22,-12,
        -18,-18,-18,-18,-18,-18,-18,-18,0,-18,0,-18,0,-18,-18,-18,-18,-18,0,-18,-18,
        -20,-20,-20,-20,-20,-20,-20,-20,0,-20,0,-20,-20,-20,-20,-20,-20,-20,-20,-20,-20,
        4,0,6,-4,7,14,10,15,0,19,0,8,0,5,16,12,0,0,0,0,-4,
        -19,-19,-19,-19,-19,-19,-19,-19,0,-19,0,-19,0,-19,-19,-19,-19,-19,0,-19,-19,
        4,0,0,0,0,14,10,0,27,0,0,8,25,0,16,12,0,0,26,0,0,
        -22,-22,-22,-22,-22,-22,-22,-22,0,-22,0,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,
        -17,-17,-17,-17,-17,-17,-17,-17,0,-17,0,-17,0,-17,-17,-17,-17,-17,0,-17,-17,
        -25,-25,-25,-25,-25,-25,-25,-25,0,-25,0,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,
        4,-6,6,-6,7,14,10,15,0,19,0,8,0,5,16,12,0,0,0,0,-6,
        -24,-24,-24,-24,-24,-24,-24,-24,0,-24,0,-24,-24,-24,-24,-24,-24,-24,-24,-24,-24,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,
        -23,-23,-23,-23,-23,-23,-23,-23,0,-23,0,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,
        -16,-16,-16,-16,-16,-16,-16,-16,0,-16,0,-16,0,-16,-16,-16,-16,-16,0,-16,-16,
        -21,-21,-21,-21,-21,-21,-21,-21,0,-21,0,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,
        0,32,0,-3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,
        4,-8,6,-8,7,14,10,15,0,19,0,8,0,5,16,12,0,0,0,0,-8,
        4,0,6,-4,7,14,10,15,0,19,0,8,0,5,16,12,0,0,0,0,-4,
        -13,-13,-13,-13,-13,-13,-13,-13,0,-13,0,-13,0,-13,-13,-13,0,0,0,0,-13,
        -15,-15,-15,-15,-15,-15,-15,-15,0,-15,0,-15,0,-15,-15,-15,0,0,0,0,-15,
        -14,-14,-14,-14,-14,-14,-14,-14,0,-14,0,-14,0,-14,-14,-14,0,0,0,0,-14,
        -11,-11,-11,-11,-11,-11,-11,-11,0,-11,0,-11,0,-11,-11,-11,0,0,0,0,-11,
        0,0,0,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        4,0,0,0,0,14,10,0,0,0,0,8,0,0,16,12,0,0,26,0,0,
        -35,0,0,0,0,-35,-35,0,0,0,37,-35,-35,0,-35,-35,0,0,-35,0,0,
        4,0,0,0,0,14,10,0,0,0,0,8,38,0,16,12,0,0,26,0,0,
        4,0,0,0,0,14,10,0,0,0,0,8,-31,0,16,12,0,0,26,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,0,
        4,0,0,0,0,14,10,0,0,0,0,8,-33,0,16,12,0,0,26,0,0,
        0,-5,0,-5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-5,
        4,0,6,-4,7,14,10,15,0,19,0,8,0,5,16,12,0,0,0,0,-4,
        0,-7,0,-7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-7,
        0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        -9,-9,-9,-9,-9,-9,-9,-9,0,-9,0,-9,0,-9,-9,-9,0,0,0,0,-9,
        0,0,0,0,0,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0,
        4,0,0,0,0,14,10,0,0,0,0,8,0,0,16,12,0,0,26,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,-30,0,0,0,0,0,0,0,0,
        -26,-26,-26,-26,-26,-26,-26,-26,0,-26,0,-26,0,-26,-26,-26,-26,-26,0,-26,-26,
        0,0,0,0,0,0,0,0,0,0,0,0,-32,0,0,0,0,0,0,0,0,
        0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,
        -10,-10,-10,-10,-10,-10,-10,-10,0,-10,0,-10,0,-10,-10,-10,0,0,0,0,-10,
        -28,-28,-28,-28,-28,-28,-28,-28,0,-28,0,-28,0,-28,-28,-28,-28,-28,0,-28,-28,
        -34,0,0,0,0,-34,-34,0,0,0,0,-34,-34,0,-34,-34,0,0,-34,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,
        -27,-27,-27,-27,-27,-27,-27,-27,0,-27,0,-27,0,-27,-27,-27,-27,-27,0,-27,-27,
        -29,-29,-29,-29,-29,-29,-29,-29,0,-29,0,-29,0,-29,-29,-29,-29,-29,0,-29,-29};
    static constexpr int productionLabels[] = {0,0,0,1,1,1,1,8,8,5,5,7,7,7,9,9,9,9,3,3,3,3,3,3,4,4,4,4,6,6,6,6,2,2};
public:
    union StackEntryPayload {
        void* _grx_object;

        StackEntryPayload() {}
        ~StackEntryPayload() {}
        StackEntryPayload(StackEntryPayload&& other) noexcept {
            std::memcpy(this, &other, sizeof(StackEntryPayload));
        }
        StackEntryPayload(const StackEntryPayload& other) noexcept {
            std::memcpy(this, &other, sizeof(StackEntryPayload));
        }
        StackEntryPayload& operator=(StackEntryPayload&& other) noexcept {
            if (this != &other) {
                std::memcpy(this, &other, sizeof(StackEntryPayload));
            }
            return *this;
        }
        StackEntryPayload& operator=(const StackEntryPayload& other) {
            if (this != &other) {
                std::memcpy(this, &other, sizeof(StackEntryPayload));
            }
            return *this;
        }
    };
private:
    struct StackEntry {
        int previousState;
        StackEntryPayload payload;
        StackEntry(int previousState, StackEntryPayload payload) : previousState(previousState), payload(std::move(payload)) {}
        StackEntry() : previousState(0) {
            payload._grx_object = nullptr;
        }
        StackEntry(StackEntry&&) = default;
    };
    static StackEntryPayload _reduction0(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction1(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction2(std::vector<StackEntry>* _grx_stack) {
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction3(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction4(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction5(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction6(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction7(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction8(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction9(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction10(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction11(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction12(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction13(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction14(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction15(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction16(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction17(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction18(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction19(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction20(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction21(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction22(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction23(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction24(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction25(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction26(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction27(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction28(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction29(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction30(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction31(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction32(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static StackEntryPayload _reduction33(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        return {._grx_object = nullptr};
    }
    static constexpr StackEntryPayload (*reductions[])(std::vector<StackEntry>*) = {_reduction0, _reduction1, _reduction2, _reduction3, _reduction4, _reduction5, _reduction6, _reduction7, _reduction8, _reduction9, _reduction10, _reduction11, _reduction12, _reduction13, _reduction14, _reduction15, _reduction16, _reduction17, _reduction18, _reduction19, _reduction20, _reduction21, _reduction22, _reduction23, _reduction24, _reduction25, _reduction26, _reduction27, _reduction28, _reduction29, _reduction30, _reduction31, _reduction32, _reduction33};

    std::vector<StackEntry> stack;
    StackEntryPayload payload;
    bool payloadInitialized = false;
public:
    Parser() {
        stack.emplace_back();
    }
    void reset() {
        stack.clear();
        stack.emplace_back();
        payloadInitialized = false;
    }
    bool parse(int tokenId, StackEntryPayload tokenPayload) {
        while (true) {
            int action = actionTable[TERMINAL_COUNT * stack.back().previousState + tokenId];
            if (action == 0) {
                return false;
            }
            if (action == -1) {
                payload = stack.back().payload;
                payloadInitialized = true;
                return true;
            }
            if (action > 0) {
                stack.emplace_back(action - 1, tokenPayload);
                return true;
            }
            const int productionIndex = -action - 2;
            const StackEntryPayload reducedProduction = reductions[productionIndex](&stack);
            const StackEntry& newState = stack.back();
            const int nextState = gotoTable[newState.previousState * NON_TERMINAL_COUNT + productionLabels[productionIndex]];
            stack.emplace_back(nextState - 1, reducedProduction);
        }
    }
    [[nodiscard]] bool successfullyParsed() const {
        return payloadInitialized;
    }
    [[nodiscard]] StackEntryPayload getValue() const {
        return payload;
    }
};

#endif