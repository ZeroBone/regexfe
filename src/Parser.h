/* This file was generated by Grammax v1.1.1 */

#ifndef GRAMMAX_PARSER_PARSER_H
#define GRAMMAX_PARSER_PARSER_H
#include <vector>
#include <cstring> // for std::memcpy

#include "ast.hpp"
#include "token.hpp"

class Parser {
private:
#define T_WORD_CHARS 0
#define T_OR 1
#define T_RIGHT_PARENTHESIS 2
#define T_LEFT_BRACKET 3
#define T_NON_DIGIT_CHARS 4
#define T_NON_WHITESPACE_CHARS 5
#define T_DOT 6
#define T_UP_ARROW 7
#define T_SPECIAL_CHARACTER 8
#define T_LEFT_PARENTHESIS_QUESTION_MARK_COLON 9
#define T_MINUS 10
#define T_DIGIT_CHARS 11
#define T_RIGHT_BRACKET 12
#define T_LEFT_PARENTHESIS 13
#define T_NON_WORD_CHARS 14
#define T_WHITESPACE_CHARS 15
#define T_QUESTION_MARK 16
#define T_STAR 17
#define T_CHARACTER 18
#define T_PLUS 19
#define T_EOF 20
#define TERMINAL_COUNT 21
#define NON_TERMINAL_COUNT 11
    static constexpr int gotoTable[] = {
        4,10,0,11,9,13,0,0,6,2,21,
        0,0,0,0,0,0,0,22,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        27,10,0,11,9,13,0,0,6,2,21,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,11,9,29,0,0,28,2,21,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        30,10,0,11,9,13,0,0,6,2,21,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,33,35,0,0,31,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,37,0,11,9,13,0,0,6,2,21,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,40,42,0,0,0,0,0,0,0,
        0,0,33,35,0,0,43,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,33,35,0,0,45,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,11,9,29,0,0,28,2,21,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,40,42,0,0,0,0,0,0,0,
        0,0,33,35,0,0,48,0,0,0,0,
        0,0,40,42,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,40,42,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0};
    static constexpr int actionTable[] = {
        19,-4,-4,16,8,18,15,0,20,7,0,17,0,14,5,3,0,0,12,0,-4,
        -12,-12,-12,-12,-12,-12,-12,0,-12,-12,0,-12,0,-12,-12,-12,24,23,-12,25,-12,
        -24,-24,-24,-24,-24,-24,-24,0,-24,-24,0,-24,-24,-24,-24,-24,-24,-24,-24,-24,-24,
        0,26,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,
        -21,-21,-21,-21,-21,-21,-21,0,-21,-21,0,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,
        -6,-6,-6,-6,-6,-6,-6,0,-6,-6,0,-6,0,-6,-6,-6,0,0,-6,0,-6,
        19,-4,-4,16,8,18,15,0,20,7,0,17,0,14,5,3,0,0,12,0,-4,
        -23,-23,-23,-23,-23,-23,-23,0,-23,-23,0,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,
        -18,-18,-18,-18,-18,-18,-18,0,-18,-18,0,-18,0,-18,-18,-18,-18,-18,-18,-18,-18,
        19,-3,-3,16,8,18,15,0,20,7,0,17,0,14,5,3,0,0,12,0,-3,
        -17,-17,-17,-17,-17,-17,-17,0,-17,-17,0,-17,0,-17,-17,-17,-17,-17,-17,-17,-17,
        -36,-36,-36,-36,-36,-36,-36,0,-36,-36,0,-36,0,-36,-36,-36,-36,-36,-36,-36,-36,
        -8,-8,-8,-8,-8,-8,-8,0,-8,-8,0,-8,0,-8,-8,-8,0,0,-8,0,-8,
        19,-4,-4,16,8,18,15,0,20,7,0,17,0,14,5,3,0,0,12,0,-4,
        -16,-16,-16,-16,-16,-16,-16,0,-16,-16,0,-16,0,-16,-16,-16,-16,-16,-16,-16,-16,
        19,0,0,0,8,18,0,32,0,0,0,17,34,0,5,3,0,0,36,0,0,
        -22,-22,-22,-22,-22,-22,-22,0,-22,-22,0,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,
        -25,-25,-25,-25,-25,-25,-25,0,-25,-25,0,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,
        -20,-20,-20,-20,-20,-20,-20,0,-20,-20,0,-20,-20,-20,-20,-20,-20,-20,-20,-20,-20,
        -37,-37,-37,-37,-37,-37,-37,0,-37,-37,0,-37,0,-37,-37,-37,-37,-37,-37,-37,-37,
        -19,-19,-19,-19,-19,-19,-19,0,-19,-19,0,-19,0,-19,-19,-19,-19,-19,-19,-19,-19,
        -11,-11,-11,-11,-11,-11,-11,0,-11,-11,0,-11,0,-11,-11,-11,0,0,-11,0,-11,
        -13,-13,-13,-13,-13,-13,-13,0,-13,-13,0,-13,0,-13,-13,-13,0,0,-13,0,-13,
        -15,-15,-15,-15,-15,-15,-15,0,-15,-15,0,-15,0,-15,-15,-15,0,0,-15,0,-15,
        -14,-14,-14,-14,-14,-14,-14,0,-14,-14,0,-14,0,-14,-14,-14,0,0,-14,0,-14,
        19,0,0,16,8,18,15,0,20,7,0,17,0,14,5,3,0,0,12,0,0,
        0,26,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        -5,-5,-5,-5,-5,-5,-5,0,-5,-5,0,-5,0,-5,-5,-5,0,0,-5,0,-5,
        -7,-7,-7,-7,-7,-7,-7,0,-7,-7,0,-7,0,-7,-7,-7,0,0,-7,0,-7,
        0,26,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        19,0,0,0,8,18,0,0,0,0,0,17,41,0,5,3,0,0,36,0,0,
        19,0,0,0,8,18,0,0,0,0,0,17,44,0,5,3,0,0,36,0,0,
        -31,0,0,0,-31,-31,0,0,0,0,0,-31,-31,0,-31,-31,0,0,-31,0,0,
        19,0,0,0,8,18,0,0,0,0,0,17,0,0,5,3,0,0,36,0,0,
        -33,0,0,0,-33,-33,0,0,0,0,0,-33,-33,0,-33,-33,0,0,-33,0,0,
        -35,0,0,0,-35,-35,0,0,0,0,46,-35,-35,0,-35,-35,0,0,-35,0,0,
        19,-2,-2,16,8,18,15,0,20,7,0,17,0,14,5,3,0,0,12,0,-2,
        -10,-10,-10,-10,-10,-10,-10,0,-10,-10,0,-10,0,-10,-10,-10,0,0,-10,0,-10,
        -9,-9,-9,-9,-9,-9,-9,0,-9,-9,0,-9,0,-9,-9,-9,0,0,-9,0,-9,
        -30,0,0,0,-30,-30,0,0,0,0,0,-30,-30,0,-30,-30,0,0,-30,0,0,
        -26,-26,-26,-26,-26,-26,-26,0,-26,-26,0,-26,0,-26,-26,-26,-26,-26,-26,-26,-26,
        -32,0,0,0,-32,-32,0,0,0,0,0,-32,-32,0,-32,-32,0,0,-32,0,0,
        19,0,0,0,8,18,0,0,0,0,0,17,47,0,5,3,0,0,36,0,0,
        19,0,0,0,8,18,0,0,0,0,0,17,0,0,5,3,0,0,36,0,0,
        19,0,0,0,8,18,0,0,0,0,0,17,49,0,5,3,0,0,36,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,0,
        -27,-27,-27,-27,-27,-27,-27,0,-27,-27,0,-27,0,-27,-27,-27,-27,-27,-27,-27,-27,
        19,0,0,0,8,18,0,0,0,0,0,17,51,0,5,3,0,0,36,0,0,
        -28,-28,-28,-28,-28,-28,-28,0,-28,-28,0,-28,0,-28,-28,-28,-28,-28,-28,-28,-28,
        -34,0,0,0,-34,-34,0,0,0,0,0,-34,-34,0,-34,-34,0,0,-34,0,0,
        -29,-29,-29,-29,-29,-29,-29,0,-29,-29,0,-29,0,-29,-29,-29,-29,-29,-29,-29,-29};
    static constexpr int productionLabels[] = {0,0,0,1,1,1,1,8,8,5,5,7,7,7,9,9,9,9,3,3,3,3,3,3,4,4,4,4,6,6,6,6,2,2,10,10};
public:
    union StackEntryPayload {
        void* _grx_object;
        Expression* expression;
        CharacterClass character_class;
        CharacterAlt* character_alt;
        MatchNode* match;
        char SPECIAL_CHARACTER;
        Quantifier quantifier;
        MatchElement* match_elem;
        char literal;
        Conjunction* conjunction;
        CharacterRange* character_range;
        CharacterSet* character_set;
        char CHARACTER;
        Group* group;

        StackEntryPayload() {}
        ~StackEntryPayload() {}
        StackEntryPayload(StackEntryPayload&& other) noexcept {
            std::memcpy(this, &other, sizeof(StackEntryPayload));
        }
        StackEntryPayload(const StackEntryPayload& other) noexcept {
            std::memcpy(this, &other, sizeof(StackEntryPayload));
        }
        StackEntryPayload& operator=(StackEntryPayload&& other) noexcept {
            if (this != &other) {
                std::memcpy(this, &other, sizeof(StackEntryPayload));
            }
            return *this;
        }
        StackEntryPayload& operator=(const StackEntryPayload& other) {
            if (this != &other) {
                std::memcpy(this, &other, sizeof(StackEntryPayload));
            }
            return *this;
        }
    };
private:
    struct StackEntry {
        int previousState;
        StackEntryPayload payload;
        StackEntry(int previousState, StackEntryPayload payload) : previousState(previousState), payload(std::move(payload)) {}
        StackEntry() : previousState(0) {
            payload._grx_object = nullptr;
        }
        StackEntry(StackEntry&&) = default;
    };
    static StackEntryPayload _reduction0(std::vector<StackEntry>* _grx_stack) {
        Conjunction* C = _grx_stack->back().payload.conjunction;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        Expression* E = _grx_stack->back().payload.expression;
        _grx_stack->pop_back();
        Expression* v;
        {
         v = E; v->children.push_back(C); 
        }
        StackEntryPayload _grx_v;
        _grx_v.expression = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction1(std::vector<StackEntry>* _grx_stack) {
        Conjunction* C = _grx_stack->back().payload.conjunction;
        _grx_stack->pop_back();
        Expression* v;
        {
         v = new Expression(C); 
        }
        StackEntryPayload _grx_v;
        _grx_v.expression = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction2(std::vector<StackEntry>* _grx_stack) {
        Expression* v;
        {
         v = new Expression(); 
        }
        StackEntryPayload _grx_v;
        _grx_v.expression = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction3(std::vector<StackEntry>* _grx_stack) {
        Group* G = _grx_stack->back().payload.group;
        _grx_stack->pop_back();
        Conjunction* C = _grx_stack->back().payload.conjunction;
        _grx_stack->pop_back();
        Conjunction* v;
        {
         v = C; v->children.push_back(G); 
        }
        StackEntryPayload _grx_v;
        _grx_v.conjunction = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction4(std::vector<StackEntry>* _grx_stack) {
        Group* G = _grx_stack->back().payload.group;
        _grx_stack->pop_back();
        Conjunction* v;
        {
         v = new Conjunction(G); 
        }
        StackEntryPayload _grx_v;
        _grx_v.conjunction = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction5(std::vector<StackEntry>* _grx_stack) {
        MatchNode* M = _grx_stack->back().payload.match;
        _grx_stack->pop_back();
        Conjunction* C = _grx_stack->back().payload.conjunction;
        _grx_stack->pop_back();
        Conjunction* v;
        {
         v = C; v->children.push_back(M); 
        }
        StackEntryPayload _grx_v;
        _grx_v.conjunction = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction6(std::vector<StackEntry>* _grx_stack) {
        MatchNode* M = _grx_stack->back().payload.match;
        _grx_stack->pop_back();
        Conjunction* v;
        {
         v = new Conjunction(M); 
        }
        StackEntryPayload _grx_v;
        _grx_v.conjunction = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction7(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        Expression* E = _grx_stack->back().payload.expression;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        Group* v;
        {
         v = new Group(false, E); 
        }
        StackEntryPayload _grx_v;
        _grx_v.group = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction8(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        Expression* E = _grx_stack->back().payload.expression;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        Group* v;
        {
         v = new Group(true, E); 
        }
        StackEntryPayload _grx_v;
        _grx_v.group = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction9(std::vector<StackEntry>* _grx_stack) {
        Quantifier Q = _grx_stack->back().payload.quantifier;
        _grx_stack->pop_back();
        MatchElement* ME = _grx_stack->back().payload.match_elem;
        _grx_stack->pop_back();
        MatchNode* v;
        {
         v = new MatchNode(ME, Q); 
        }
        StackEntryPayload _grx_v;
        _grx_v.match = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction10(std::vector<StackEntry>* _grx_stack) {
        MatchElement* ME = _grx_stack->back().payload.match_elem;
        _grx_stack->pop_back();
        MatchNode* v;
        {
         v = new MatchNode(ME); 
        }
        StackEntryPayload _grx_v;
        _grx_v.match = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction11(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        Quantifier v;
        {
         v = Quantifier::Star; 
        }
        StackEntryPayload _grx_v;
        _grx_v.quantifier = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction12(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        Quantifier v;
        {
         v = Quantifier::Plus; 
        }
        StackEntryPayload _grx_v;
        _grx_v.quantifier = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction13(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        Quantifier v;
        {
         v = Quantifier::QuestionMark; 
        }
        StackEntryPayload _grx_v;
        _grx_v.quantifier = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction14(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        MatchElement* v;
        {
         v = new DotMatchElement(); 
        }
        StackEntryPayload _grx_v;
        _grx_v.match_elem = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction15(std::vector<StackEntry>* _grx_stack) {
        CharacterClass CC = _grx_stack->back().payload.character_class;
        _grx_stack->pop_back();
        MatchElement* v;
        {
         v = new CharacterClassMatchElement(CC); 
        }
        StackEntryPayload _grx_v;
        _grx_v.match_elem = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction16(std::vector<StackEntry>* _grx_stack) {
        CharacterAlt* CA = _grx_stack->back().payload.character_alt;
        _grx_stack->pop_back();
        MatchElement* v;
        {
         v = new CharacterAltMatchElement(CA); 
        }
        StackEntryPayload _grx_v;
        _grx_v.match_elem = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction17(std::vector<StackEntry>* _grx_stack) {
        char L = _grx_stack->back().payload.literal;
        _grx_stack->pop_back();
        MatchElement* v;
        {
         v = new LiteralMatchElement(L); 
        }
        StackEntryPayload _grx_v;
        _grx_v.match_elem = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction18(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterClass v;
        {
         v = CharacterClass::WordChars; 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_class = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction19(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterClass v;
        {
         v = CharacterClass::NonWordChars; 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_class = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction20(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterClass v;
        {
         v = CharacterClass::DigitChars; 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_class = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction21(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterClass v;
        {
         v = CharacterClass::NonDigitChars; 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_class = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction22(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterClass v;
        {
         v = CharacterClass::WhiteSpaceChars; 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_class = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction23(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterClass v;
        {
         v = CharacterClass::NonWhiteSpaceChars; 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_class = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction24(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterSet* CS = _grx_stack->back().payload.character_set;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        CharacterAlt* v;
        {
         v = new CharacterAlt(CharacterAltType::Normal, CS); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_alt = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction25(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterSet* CS = _grx_stack->back().payload.character_set;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        CharacterAlt* v;
        {
         v = new CharacterAlt(CharacterAltType::Negated, CS); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_alt = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction26(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterSet* CS = _grx_stack->back().payload.character_set;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        CharacterAlt* v;
        {
         v = new CharacterAlt(CharacterAltType::NormalIncludingClosingBracket, CS); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_alt = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction27(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        CharacterSet* CS = _grx_stack->back().payload.character_set;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        CharacterAlt* v;
        {
         v = new CharacterAlt(CharacterAltType::NormalNotIncludingClosingBracket, CS); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_alt = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction28(std::vector<StackEntry>* _grx_stack) {
        CharacterRange* CR = _grx_stack->back().payload.character_range;
        _grx_stack->pop_back();
        CharacterSet* CS = _grx_stack->back().payload.character_set;
        _grx_stack->pop_back();
        CharacterSet* v;
        {
         v = CS; v->ranges.push_back(CR); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_set = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction29(std::vector<StackEntry>* _grx_stack) {
        CharacterRange* CR = _grx_stack->back().payload.character_range;
        _grx_stack->pop_back();
        CharacterSet* v;
        {
         v = new CharacterSet(CR); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_set = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction30(std::vector<StackEntry>* _grx_stack) {
        CharacterClass CC = _grx_stack->back().payload.character_class;
        _grx_stack->pop_back();
        CharacterSet* CS = _grx_stack->back().payload.character_set;
        _grx_stack->pop_back();
        CharacterSet* v;
        {
         v = CS; v->classes.push_back(CC); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_set = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction31(std::vector<StackEntry>* _grx_stack) {
        CharacterClass CC = _grx_stack->back().payload.character_class;
        _grx_stack->pop_back();
        CharacterSet* v;
        {
         v = new CharacterSet(CC); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_set = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction32(std::vector<StackEntry>* _grx_stack) {
        char UB = _grx_stack->back().payload.CHARACTER;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        char LB = _grx_stack->back().payload.CHARACTER;
        _grx_stack->pop_back();
        CharacterRange* v;
        {
         v = new CharacterRange(LB, UB); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_range = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction33(std::vector<StackEntry>* _grx_stack) {
        char C = _grx_stack->back().payload.CHARACTER;
        _grx_stack->pop_back();
        CharacterRange* v;
        {
         v = new CharacterRange(C); 
        }
        StackEntryPayload _grx_v;
        _grx_v.character_range = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction34(std::vector<StackEntry>* _grx_stack) {
        char C = _grx_stack->back().payload.CHARACTER;
        _grx_stack->pop_back();
        char v;
        {
         v = C; 
        }
        StackEntryPayload _grx_v;
        _grx_v.literal = v;
        return _grx_v;
    }
    static StackEntryPayload _reduction35(std::vector<StackEntry>* _grx_stack) {
        char SC = _grx_stack->back().payload.SPECIAL_CHARACTER;
        _grx_stack->pop_back();
        char v;
        {
         v = SC; 
        }
        StackEntryPayload _grx_v;
        _grx_v.literal = v;
        return _grx_v;
    }
    static constexpr StackEntryPayload (*reductions[])(std::vector<StackEntry>*) = {_reduction0, _reduction1, _reduction2, _reduction3, _reduction4, _reduction5, _reduction6, _reduction7, _reduction8, _reduction9, _reduction10, _reduction11, _reduction12, _reduction13, _reduction14, _reduction15, _reduction16, _reduction17, _reduction18, _reduction19, _reduction20, _reduction21, _reduction22, _reduction23, _reduction24, _reduction25, _reduction26, _reduction27, _reduction28, _reduction29, _reduction30, _reduction31, _reduction32, _reduction33, _reduction34, _reduction35};

    std::vector<StackEntry> stack;
    StackEntryPayload payload;
    bool payloadInitialized = false;
public:
    Parser() {
        stack.emplace_back();
    }
    void reset() {
        stack.clear();
        stack.emplace_back();
        payloadInitialized = false;
    }
    bool parse(int tokenId, StackEntryPayload tokenPayload) {
        while (true) {
            int action = actionTable[TERMINAL_COUNT * stack.back().previousState + tokenId];
            if (action == 0) {
                return false;
            }
            if (action == -1) {
                payload = stack.back().payload;
                payloadInitialized = true;
                return true;
            }
            if (action > 0) {
                stack.emplace_back(action - 1, tokenPayload);
                return true;
            }
            const int productionIndex = -action - 2;
            const StackEntryPayload reducedProduction = reductions[productionIndex](&stack);
            const StackEntry& newState = stack.back();
            const int nextState = gotoTable[newState.previousState * NON_TERMINAL_COUNT + productionLabels[productionIndex]];
            stack.emplace_back(nextState - 1, reducedProduction);
        }
    }
    [[nodiscard]] bool successfullyParsed() const {
        return payloadInitialized;
    }
    [[nodiscard]] StackEntryPayload getValue() const {
        return payload;
    }
};

#endif